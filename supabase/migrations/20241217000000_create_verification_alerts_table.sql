-- Create verification alerts table for monitoring system
-- Part of task 11: Add monitoring and analytics for verification process

CREATE TABLE IF NOT EXISTS verification_alerts (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,
  severity TEXT NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  metadata JSONB DEFAULT '{}',
  threshold NUMERIC,
  current_value NUMERIC,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  resolved_at TIMESTAMP WITH TIME ZONE,
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'resolved', 'acknowledged'))
);

-- Create indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_verification_alerts_status ON verification_alerts(status);
CREATE INDEX IF NOT EXISTS idx_verification_alerts_type ON verification_alerts(type);
CREATE INDEX IF NOT EXISTS idx_verification_alerts_severity ON verification_alerts(severity);
CREATE INDEX IF NOT EXISTS idx_verification_alerts_created_at ON verification_alerts(created_at);

-- Add RLS policies
ALTER TABLE verification_alerts ENABLE ROW LEVEL SECURITY;

-- Only allow admin users to view alerts (you may need to adjust this based on your admin role setup)
CREATE POLICY "Admin users can view alerts" ON verification_alerts
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.id = auth.uid() 
      AND profiles.role = 'admin'
    )
  );

-- Only allow admin users to update alerts (resolve/acknowledge)
CREATE POLICY "Admin users can update alerts" ON verification_alerts
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.id = auth.uid() 
      AND profiles.role = 'admin'
    )
  );

-- Allow system to insert alerts (service role)
CREATE POLICY "System can insert alerts" ON verification_alerts
  FOR INSERT
  WITH CHECK (true);

-- Add helpful functions for alert management
CREATE OR REPLACE FUNCTION get_alert_summary(time_window_hours INTEGER DEFAULT 24)
RETURNS TABLE (
  alert_type TEXT,
  severity TEXT,
  count BIGINT,
  latest_alert TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    va.type as alert_type,
    va.severity,
    COUNT(*) as count,
    MAX(va.created_at) as latest_alert
  FROM verification_alerts va
  WHERE va.created_at >= NOW() - (time_window_hours || ' hours')::INTERVAL
  GROUP BY va.type, va.severity
  ORDER BY count DESC, latest_alert DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to auto-resolve old alerts
CREATE OR REPLACE FUNCTION auto_resolve_old_alerts(hours_old INTEGER DEFAULT 72)
RETURNS INTEGER AS $$
DECLARE
  resolved_count INTEGER;
BEGIN
  UPDATE verification_alerts 
  SET 
    status = 'resolved',
    resolved_at = NOW()
  WHERE 
    status = 'active' 
    AND created_at < NOW() - (hours_old || ' hours')::INTERVAL;
  
  GET DIAGNOSTICS resolved_count = ROW_COUNT;
  RETURN resolved_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add comment for documentation
COMMENT ON TABLE verification_alerts IS 'Stores alerts generated by the verification monitoring system';
COMMENT ON FUNCTION get_alert_summary IS 'Returns summary of alerts within specified time window';
COMMENT ON FUNCTION auto_resolve_old_alerts IS 'Automatically resolves alerts older than specified hours';